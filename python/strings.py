#!/usr/bin/env python3
"""resource_strings.py
Finds realistic malware-related strings in *suspicious* APK resource files using ripgrep directly on binaries.
Reads the list of suspicious files from 'suspicious_resources_for_strings.txt'.
Focuses on patterns likely hidden in resources.
REDUCED NOISE: Patterns are more specific to potential threats in resources.
"""
import subprocess
import sys
import os

# More specific patterns likely to indicate malicious data hidden in resources
# Avoiding overly generic patterns that match normal app strings.
RESOURCE_STRINGS_PATTERNS = [
    # --- C&C Communication (more specific) ---
    # URLs containing specific paths often used by malware (e.g., /api/login, /upload, /cmd)
    r"https?://[a-zA-Z0-9\.-]+\.(com|net|org|io|ru|tk|ml|ga|cf|top|xyz|onion)/(api|upload|cmd|login|control|bot)/[a-zA-Z0-9\./\-_%\?=&]*",
    # SOCKS proxy (relatively specific)
    r"socks[45]://[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}:[0-9]{1,5}",
    # --- Identifiers / Secrets (more specific) ---
    # Long base64 strings *likely* containing keys or significant data (length > 50, avoids short base64 fragments)
    r"[a-zA-Z0-9+/]{50,}={0,2}",
    # RSA/EC/DSA private keys (specific start/end markers)
    r"-----BEGIN (?:RSA |EC |DSA )?PRIVATE KEY-----",
    # --- Commands / Actions (specific to Android control) ---
    # Direct system execution from resources (less common in legitimate resources)
    r"Runtime\.getRuntime\(\)\.exec\(",
    r"ProcessBuilder\(",
    # Specific Android commands for persistence/modification
    r"pm install -r ", # Install with replace flag
    r"pm install -t ", # Install with test flag
    r"am start -n [a-zA-Z0-9_\.]+/\.?[^/\s]+ --ei", # am start with extra intent data
    r"am broadcast -n [a-zA-Z0-9_\.]+/\.?[^/\s]+ --es", # am broadcast with extra string data
    # --- Crypto / Persistence (more specific) ---
    # Specific crypto mode combinations often used for encryption
    r"(?:AES|RSA|ChaCha20|Salsa20|Curve25519|Ed25519)\s*(?:\+|/|-)\s*(?:GCM|CTR)",
    # Accessing specific sensitive system directories from resources
    r"/data/data/[a-zA-Z0-9_\.]+/(shared_prefs|databases|cache)/", # Specific sensitive subdirs
    # --- Other Highly Suspicious ---
    # Common malware command strings (often found in config/resource files)
    r"(?:exec_cmd|run_shell|execute_now|send_data_to_server)",
    # Specific malware-related filenames or paths
    r"/dev/(?:shm|pts/[0-9]+)", # Shared memory, pseudo-terminals
    r"(?:/system/bin/|/system/xbin/)(?:su|busybox|lib\S*\.so)", # Specific tools/binaries
]

def search_strings_in_file(res_file: str, patterns: list[str]):
    """Search for patterns in a single file."""
    results = []
    for pattern in patterns:
        # Use ripgrep directly on the binary file
        # -a treats binary as text for matching
        # -o outputs only the matching part
        # -P enables PCRE2 regex
        # --color=never avoids ANSI codes in output
        cmd = ['rg', '-a', '-o', '-P', '--color=never', pattern, res_file]
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=False) # check=False handles non-zero exit codes gracefully
        except FileNotFoundError:
            print("[*] ERROR: 'rg' (ripgrep) not found. Please install ripgrep.", file=sys.stderr)
            sys.exit(1)

        if result.returncode == 0: # Matches found
            matches = list(filter(None, result.stdout.strip().split('\n')))
            if matches:
                # Group matches by pattern for this file
                results.append((pattern, matches))
    return results

def main():
    # Read the list of suspicious files from the file generated by steganography.py
    suspicious_file_list = "suspicious_resources_for_strings.txt"
    if not os.path.exists(suspicious_file_list):
        print(f"[*] ERROR: File list '{suspicious_file_list}' not found. Did steganography.py run and find anything?", file=sys.stderr)
        sys.exit(1)

    with open(suspicious_file_list, 'r') as f:
        resource_files = [line.strip() for line in f if line.strip()]

    if not resource_files:
        print(f"[*] No suspicious files listed in '{suspicious_file_list}'. Nothing to scan for strings.")
        return

    # Search strings in each file listed
    found_count = 0
    for res_file in resource_files:
        if not os.path.exists(res_file):
            print(f"[*] WARNING: Suspicious file listed but not found: {res_file}", file=sys.stderr)
            continue # Skip if the file doesn't exist anymore

        file_results = search_strings_in_file(res_file, RESOURCE_STRINGS_PATTERNS)
        if file_results: # If any patterns matched in this file
            print(f"[*] FOUND STRINGS IN {res_file}:")
            for pattern, matches in file_results:
                for match in matches:
                    if match: # Filter out empty strings if any
                        print(f"    [*] FOUND STRING:")
                        print(f"        [*] STRING: '{match}'")
                        print(f"        [*] OF PATTERN: '{pattern}'")
            print() # Add a blank line after each file's results
            found_count += 1

    if found_count == 0:
        print(f"[*] TOTAL: {found_count} suspicious string matches found across {len(resource_files)} suspicious files scanned.")
    else:
        print(f"[*] TOTAL: {found_count} files with suspicious string matches found out of {len(resource_files)} suspicious files scanned.")

if __name__ == "__main__":
    main()