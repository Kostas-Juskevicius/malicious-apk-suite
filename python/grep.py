#!/usr/bin/env python3
import subprocess
import sys
import json

"""Greps malicious code patterns in jadx decompilation output"""

SOURCES_DIR = sys.argv[1] if len(sys.argv) > 1 else sys.exit("[*] ERROR: you must pass the path to jadx output of sources as the first arg.")

SKIP_PACKAGES = [
    'kotlin/',
    'kotlinx/',
    'androidx/',
    'android/support/',
    'com/google/android/gms/',
    'com/google/firebase/',
    'com/google/android/datatransport/',
    'org/jetbrains/',
    'java/',
    'javax/',
    'sun/',
    'org/apache/',
    'okhttp3/',
    'retrofit2/',
    'com/squareup/',
]

# todo
CRYPTO_PATTERNS = [
    r"\.decrypt\(",
    r"\.encrypt\(",
    r"Cipher\.getInstance",
    r"javax\.crypto",
    r"java\.security",
    r"SecretKeySpec",
    r"IvParameterSpec",
    r"KeyGenerator",
]

# todo
BASE64_PATTERNS = [
    r"Base64\.decode",
    r"Base64\.encode",
    r"getDecoder\(\)",
    r"getEncoder\(\)",
    r'aHR0cDovL2',  # http:// in base64
    r'aHR0cHM6Ly9',  # https:// in base64
    r'"[a-zA-Z0-9+/]{5,}={1,2}"',
    r"'[a-zA-Z0-9+/]{5,}={1,2}'",
]

HARDCODED_KEYS = [
    r'"[A-Za-z0-9+/]{40,}={0,2}"',  # long base64 strings
]

# todo
DROPPER_PATTERNS = [
    r"ACTION_INSTALL_PACKAGE",
    r"PackageInstaller",
    r"\.installPackage\(",
    r"INSTALL_PACKAGES",
    r"REQUEST_INSTALL_PACKAGES",
]

# todo
SMS_PATTERNS = [
    r"SmsManager",
    r"\.sendTextMessage\(",
    r"SMS_RECEIVED",
    r"android\.provider\.Telephony",
    r"getDefault\(\)\.sendTextMessage",
]

# todo
ACCESSIBILITY_PATTERNS = [
    r"AccessibilityService\b",
    r"TYPE_ACCESSIBILITY_OVERLAY",
    r"TYPE_APPLICATION_OVERLAY",
    r"SYSTEM_ALERT_WINDOW",
    r"AccessibilityEvent",
    r"performGlobalAction",
]

STRING_CONCATENATION_PATTERNS = [
    r'"\s*\+\s*"',
]

# todo
WEBVIEW_PATTERNS = [
    r"WebView",
    r"loadUrl\(",
    r"addJavascriptInterface",
    r"setJavaScriptEnabled",
    r"evaluateJavascript",
]

# todo
REFLECTION_PATTERNS = [
    r"Class\.forName\(",
    r"\.getMethod\(",
    r"\.invoke\(",
    r"getDeclaredMethod",
    r"\.newInstance\(",
]

# todo
DYNAMIC_LOADING_PATTERNS = [
    r"DexClassLoader",
    r"PathClassLoader",
    r"\.loadClass\(",
    r"DexFile",
    r"loadDex",
]

# todo
NETWORK_PATTERNS = [
    r"HttpURLConnection",
    r"OkHttpClient",
    r"\.openConnection\(",
    r"HttpClient",
    r"\.execute\(",
    r"Socket\(",
]

FILE_OPS_PATTERNS = [
    r"\"java.io.tmpdir\"",
    r"new\s+FileWriter",
    r"Files\.(?:exists|readAllLines|readAllBytes|write|delete|copy|move)",
    r"FileOutputStream",
    r"FileInputStream",
    r"FileChannel",
    r"new Scanner\(new File\(",
    r"AsynchronousFileChannel",
    r"File.(?:delete|deleteOnExit)",
    r"File.(?:exists|canRead|canWrite|list|listFiles|newDirectoryStream)",
]

COMMAND_EXECUTION_PATTERNS = [
    r"Runtime\.getRuntime\(\)\.exec",
]

NATIVE_PATTERNS = [
    r"System\.loadLibrary\(\"(?!.*(?:firebase|gms)).*\"\)",  # exclude firebase/gms
    r"System\.load\(\"(?!.*(?:firebase|gms)).*\"\)",  # exclude firebase/gms
    r"(?:static\s+)?native\s+\w+\s+\w",
]

LOGGING_PATTERNS = [
    r"Log\.[a-z]\(",  # Log.d(, Log.e(, etc
]

PERSISTENCT_SERVICE_PATTERNS = [
    r"START_STICKY",
]

IMAGE_PAYLOAD_PATTERNS = [
    r"getPixel",
]


def grep_and_print(label, patterns, exclude_patterns):
    cmd = ["rg", "--json", "--type", "java", "-P"]
    for p in patterns:
        cmd.extend(["-e", p])
    cmd.append(SOURCES_DIR)
    
    result = subprocess.run(cmd, capture_output=True, text=True)

    lines = result.stdout.strip().split('\n')
    pattern_header_printed = False
    for line in filter(None, lines):
        data = json.loads(line)
        if data.get('type') != 'match':
            continue

        m = data['data']
        filepath = m['path']['text']
        line_text = m['lines']['text'].strip() # misleading key. its a single line, not 'lines'

        # skip grepping from packages e. g. legit packages                
        skip = False
        for pkg in SKIP_PACKAGES:
            if pkg in filepath:
                skip = True
                break
        if skip:
            continue

        # skip words e. g. if method is /* synthetic */ - generated by jadx decompiler, not written by malware dev
        for exclude in exclude_patterns:
            if exclude in line_text:
                skip = True
                break
        if skip:
            continue

        if not pattern_header_printed:
            print(f"[*] GREPPING FOR {label}...")
            pattern_header_printed = True
            
        print(f"[*] FOUND {label}: {line_text} in {filepath} at line {m['line_number']}")
    
    if pattern_header_printed:
        print()


LABELS = [
    ("CRYPTO", CRYPTO_PATTERNS, []),
    ("BASE64", BASE64_PATTERNS, []),
    ("KEY", HARDCODED_KEYS, []),
    ("DROPPER", DROPPER_PATTERNS, []),
    ("SMS", SMS_PATTERNS, []),
    ("ACCESSIBILITY", ACCESSIBILITY_PATTERNS, []),
    ("STRING CONCATENATION", STRING_CONCATENATION_PATTERNS, []),
    ("WEBVIEW", WEBVIEW_PATTERNS, []),
    ("REFLECTION", REFLECTION_PATTERNS, []),
    ("DYNAMIC LOADING", DYNAMIC_LOADING_PATTERNS, []),
    ("NETWORK", NETWORK_PATTERNS, []),
    ("COMMAND_EXECUTION_PATTERNS", COMMAND_EXECUTION_PATTERNS, []),
    ("FILE OPS", FILE_OPS_PATTERNS, []),
    ("NATIVE", NATIVE_PATTERNS, ["synthetic"]),
    ("LOG", LOGGING_PATTERNS, []),
    ("SERVICE PERSISTENCE", PERSISTENCT_SERVICE_PATTERNS, []),
]
 
for label, patterns, exclude in LABELS:
    grep_and_print(label, patterns, exclude)
print("\n[*] GREPPING COMPLETE\n")