# 958fe0ad35fd2e1574e458084e26d790c57356cbcc13057855e36b71b00c4198.apk

Malware SHA256: 958fe0ad35fd2e1574e458084e26d790c57356cbcc13057855e36b71b00c4198.apk

## Steps

### 1. Scripts

I ran my automatic scripts for initial quick overview of `jadx` output and noted these things:

```log
...
[*] FOUND NATIVE: System.loadLibrary("lxofq"); in /home/litoracle/projects/apk8/malicious-apk-suite/jadx/sources/pv40ig/c4yjao.java at line 10
...
[*] FOUND STRING  / PATTERN: 'https://' in /home/litoracle/projects/apk8/malicious-apk-suite/jadx/resources/lib/arm64-v8a/liblxofq.so

[*] FOUND STRING  / PATTERN: 'https://' in /home/litoracle/projects/apk8/malicious-apk-suite/jadx/resources/lib/armeabi-v7a/liblxofq.so
...
```

Under Resources/assets there seems to be quite a few binary / encrypted / gibberish files. Under Resources/lib there is only 1 library called "liblxofq\.so", matching the one being loaded.

```java
package pv40ig;

import android.app.Application;
import android.content.Context;
import defpackage.LeePh2ZieYo1EHoX;

/* loaded from: classes.dex */
public class c4yjao extends Application {
    static {
        System.loadLibrary("lxofq");
    }

    public c4yjao() {
        new LeePh2ZieYo1EHoX();
    }

    @Override // android.content.ContextWrapper
    public native void attachBaseContext(Context context);
}
```

The library is being loaded in a `static {}` block inside the Application class. Interestingly, attachment of base context, which also happens very early in the app lifecycle, is itself marked a native method.

Since this happens so early, I should probably already be looking into the .so file, but before that I will follow the Java code a little more, as it appears to be linear.

The method called from the Application constructor:

```java
public LeePh2ZieYo1EHoX() {
    System.load(System.getProperty("java.io.tmpdir") + "/l");
}
```

This does the same as loadLibrary(), but you have to specify the full path.

Why would it load it from the temp directory? Nevermind that, why would there be some native library in your Android's temporary directory?

This leads me to believe our initial .so doesn't have the bulk of the malicious behaviour, but acts as a loader for the other payload.

### 2. Reverse engineering the library with Ghidra

There are 2 versions of the .so: `lib/arm64-v8a` and `lib/armeabi-v7a`. I never thought much of this, but now is a good opportunity for me to look into the differences of them.

The logic within them _should_ be the same, but I've heard that arm64 is more readable and modern devices are usually arm64, so I will try looking this one.

Early in the dissasembled code there is a reference to other libs:

```asm
        00100538 6c 69 62        utf8       u8"libc.so"
                 63 2e 73
                 6f 00
        00100540 4c 49 42        utf8       u8"LIBC"
                 43 00
        00100545 6c 69 62        utf8       u8"liblog.so"
                 6c 6f 67
                 2e 73 6f 00
        0010054f 6c 69 62        utf8       u8"libm.so"
                 6d 2e 73
                 6f 00
        00100557 6c 69 62        utf8       u8"libdl.so"
                 64 6c 2e
                 73 6f 00
        00100560 6c 69 62        utf8       u8"liblxofq.so"
                 6c 78 6f
                 66 71 2e
```

Although those seem to be harmless, except for `libdl.so` - lib for dynamic loading.

I also went to the .rodata section which means read only data. There were some more strings.

One that caught my attention:

```asm
                             s_java.io.tmpdir_00100751                       XREF[1]:     JNI_OnLoad:00100a18(*)
        00100751 6a 61 76        ds         "java.io.tmpdir"
                 61 2e 69
                 6f 2e 74
```

This reinforces the guess that this .so file loads another .so in the temp directory, and in Java code that directory is accessed again to load the library.

I also see `__android_log_print` under those imports, this is worth keeping in mind, if I find it called with some specific tag I can use `adb` with my Android emulator to check the logs being output.

`__android_log_print(4,"loader","JNI_OnLoad started.");` at least in this case the tag is "loader".

Anyways. The entire function where I suspect the writing of the real payload to happen:

```c
undefined4 JNI_OnLoad(long *param_1)

{
  long lVar1;
  int iVar2;
  long lVar3;
  long lVar4;
  long lVar5;
  byte *__dest;
  FILE *__s;
  byte bVar6;
  byte *pbVar7;
  undefined4 uVar8;
  size_t __size;
  long *local_1050;
  char acStack_1048 [4096];
  long local_48;

  lVar1 = tpidr_el0;
  local_48 = *(long *)(lVar1 + 0x28);
  uVar8 = 0x10006;
  local_1050 = (long *)0x0;
  iVar2 = (**(code **)(*param_1 + 0x30))(param_1,&local_1050,0x10006);
  if (iVar2 == 0) {
    __android_log_print(4,"loader","JNI_OnLoad started.");
    lVar3 = (**(code **)(*local_1050 + 0x30))(local_1050,"java/lang/System");
    if ((((lVar3 != 0) &&
         (lVar4 = (**(code **)(*local_1050 + 0x388))
                            (local_1050,lVar3,"getProperty","(Ljava/lang/String;)Ljava/lang/String;"
                            ), lVar4 != 0)) &&
        (lVar5 = (**(code **)(*local_1050 + 0x538))(local_1050,"java.io.tmpdir"), lVar5 != 0)) &&
       ((lVar3 = (**(code **)(*local_1050 + 0x390))(local_1050,lVar3,lVar4,lVar5), lVar3 != 0 &&
        (lVar4 = (**(code **)(*local_1050 + 0x548))(local_1050,lVar3,0), lVar4 != 0)))) {
      FUN_00100b3c(acStack_1048);
      (**(code **)(*local_1050 + 0x550))(local_1050,lVar3,lVar4);
      iVar2 = DAT_0017dd38;
      __size = (size_t)DAT_0017dd38;
      __dest = (byte *)malloc(__size);
      memcpy(__dest,&DAT_00102f00,__size);
      if (0 < iVar2) {
        bVar6 = 0x44;
        pbVar7 = __dest;
        do {
          bVar6 = bVar6 * '\r' + 0x5f;
          __size = __size - 1;
          *pbVar7 = *pbVar7 ^ bVar6;
          pbVar7 = pbVar7 + 1;
        } while (__size != 0);
      }
      __s = fopen(acStack_1048,"wb");
      if (__s != (FILE *)0x0) {
        fwrite(__dest,1,(long)DAT_0017dd38,__s);
        fclose(__s);
        free(__dest);
        goto LAB_0010097c;
      }
    }
  }
  uVar8 = 0xffffffff;
LAB_0010097c:
  if (*(long *)(lVar1 + 0x28) == local_48) {
    return uVar8;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
```

I tried renaming some variables and adding some comments, bit by bit making this a little clearer:

```c
int JNI_OnLoad(void *vm)

{
  long lVar1;
  long lVar2;
  long lVar3;
  byte *malloc_result_ptr;
  FILE *FILE_struct_ptr;
  byte xor_key;
  byte *iteration_byte_ptr;
  int ignore_this;
  size_t __size;
  long *object_pointer;
  char filename [4096];
  long canary;
  int ???;
  long this_threads_private_storage;

                    /* ignore this - stack overflow check */
  this_threads_private_storage = tpidr_el0;
  canary = *(long *)(this_threads_private_storage + 0x28);
                    /* <end of ignore this> */
  ignore_this = 0x10006;
                    /* WARNING: Load size is inaccurate */
                    /* this 0x0 isnt an int, actually its NULL (NULL is a macro that expands to
                       (void *) 0, so this variable is an object, not some long ptr) */
  object_pointer = (long *)0x0;
                    /* (*vm + 0x30): vm - arg always passed to JNI_OnLoad, true type not "void *"
                       but "JavaVM *", its a pointer that points to vtable - function table (set of
                       function pointers)

                       so offseting it may be like offseting the function table - choosing which
                       method to call on an object

                       code - ghidra's type for executable code / function

                       deferencing it twice probably gets the method

                       but before that, (*vm + 0x30) is cast to (code **), because that's what it
                       is, a ** to executable code

                       (vm,&object_pointer,0x10006) is just 3 arguments. first is vm, that may be
                       "this" - what instance to call it on (i assume function ptrs is how class
                       methods work under the hood and they probably need to know the instance) */
  ??? = (**(code **)(*vm + 0x30))(vm,&object_pointer,0x10006);
  if (??? == 0) {
    __android_log_print(4,"loader","JNI_OnLoad started.");
    lVar1 = (**(code **)(*object_pointer + 0x30))(object_pointer,"java/lang/System");
                    /* "if we manage to do something with temp dir" */
                    /* 1 big if condition */
    if ((((lVar1 != 0) &&
         (lVar2 = (**(code **)(*object_pointer + 0x388))
                            (object_pointer,lVar1,"getProperty",
                             "(Ljava/lang/String;)Ljava/lang/String;"), lVar2 != 0)) &&
        (lVar3 = (**(code **)(*object_pointer + 0x538))(object_pointer,"java.io.tmpdir"), lVar3 != 0
        )) && ((lVar1 = (**(code **)(*object_pointer + 0x390))(object_pointer,lVar1,lVar2,lVar3),
               lVar1 != 0 &&
               (lVar2 = (**(code **)(*object_pointer + 0x548))(object_pointer,lVar1,0), lVar2 != 0))
              )) {
                    /* end of if condition

                       func that probably initializes the filename under temp dir */
      FUN_00100b3c(filename);
      (**(code **)(*object_pointer + 0x550))(object_pointer,lVar1,lVar2);
      ??? = DATA_SIZE_T_IS_0007AE38h;
      __size = (size_t)DATA_SIZE_T_IS_0007AE38h;
      malloc_result_ptr = (byte *)malloc(__size);
                    /* some kind of predefined bytes are copied to what we malloced in size of
                       0x0007AE38. those bytes were at 0xAC */
      memcpy(malloc_result_ptr,&DATA_MEMCPY_SRC_IS_00102f00,__size);
      if (0 < ???) {
        xor_key = 0x44;
        iteration_byte_ptr = malloc_result_ptr;
        do {
                    /* update xor key to another */
          xor_key = xor_key * '\r' + 0x5f;
                    /* size-- (do this for all malloc'ed bytes) */
          __size = __size - 1;
                    /* decrypt bytes */
          *iteration_byte_ptr = *iteration_byte_ptr ^ xor_key;
          iteration_byte_ptr = iteration_byte_ptr + 1;
        } while (__size != 0);
      }
                    /* write binary - the decrypted file */
      FILE_struct_ptr = fopen(filename,"wb");
      if (FILE_struct_ptr != (FILE *)0x0) {
        fwrite(malloc_result_ptr,1,(long)DATA_SIZE_T_IS_0007AE38h,FILE_struct_ptr);
        fclose(FILE_struct_ptr);
        free(malloc_result_ptr);
        goto LAB_0010097c;
      }
    }
  }
  ignore_this = -1;
LAB_0010097c:
                    /* ignore this - stack overflow check */
  if (*(long *)(this_threads_private_storage + 0x28) == canary) {
    return ignore_this;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}
```

When the .so library was initially loaded, Java:

- mapped the library into memory,
- looked for JNI_OnLoad (the function above!) and called it once, passing it `JavaVM *vm`,
- the library is now loaded fully and `native` method calls go directly to C functions.

Our .so file doesn't really export anything, and we can already tell that most of the important stuff happens in this JNI_OnLoad function alone. After analyzing it, this indeed seems to decrypt the payload that Java will later access under `temp/l`. This is the filename creation in `FUN_00100b3c(filename);`:

```c
void FUN_00100b3c(char *param_1)

{
  long lVar1;
  int iVar2;
  undefined8 in_x4;
  undefined8 in_x5;
  undefined8 in_x6;
  undefined8 in_x7;
  long lVar3;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 uStack_80;
  undefined8 local_78;
  undefined1 *local_70;
  undefined1 **ppuStack_68;
  undefined8 *puStack_60;
  undefined8 uStack_58;

  ppuStack_68 = &local_70;
  puStack_60 = &local_90;
  lVar1 = tpidr_el0;
  lVar3 = *(long *)(lVar1 + 0x28);
  uStack_58 = 0xffffff80ffffffe0;
  local_90 = in_x4;
  local_88 = in_x5;
  uStack_80 = in_x6;
  local_78 = in_x7;
  local_70 = (undefined1 *)register0x00000008;
  iVar2 = vsnprintf(param_1,0x1000,"%s/l",&local_70);
  if (*(long *)(lVar1 + 0x28) == lVar3) {
    return;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail(iVar2);
}
```

Namely, the C++ function `vsnprintf(param_1,0x1000,"%s/l",&local_70);` writes the name as `"%s/l"`, where I assume `local_70` has the full temp dir string that the prior gigantic if-condition got.

### 3. Decrypting the payload

First, I got myself the bin referenced in the addresses: bytes starting at `0x00102F00` and continuing for `0x0007AE38` bytes.

Ghidra had a byte selection menu option, but for some reason it unintuitively also selected addresses next to those bytes. So in the end I just used `dd`: `dd if=jadx/resources/lib/arm64-v8a/liblxofq.so of=encrypted.bin bs=1 skip=$((0x2f00)) count=$((0x7AE38))`.

The good thing about XOR, is that applied the second time, the same way with the same key it easily decrypts the payload.

Small script:

```python
#!/usr/bin/env python3

with open("encrypted.bin", "rb") as f:
    bytes = bytearray(f.read())
print(f"verifying length: 0x7AE38 = 0x{len(bytes):x}")

xor_key = 0x44

for i in range(len(bytes)):
    xor_key = (xor_key * int(hex(ord("\r")), 16) + 0x5f) & 0xff # keep it 1 byte - "and" op removes anything beyond
    bytes[i] ^= xor_key

with open("decrypted.bin", "wb") as f:
    f.write(bytes)
```

### 4. Payload analysis

For whatever reason, there was a bit of a missmatch in size: `verifying length: 0x7AE38 = 0x79590`. I have no idea why, so for now I just ignored this and went to check how Ghidra interpreted the new bin. I selected AARCH64, v8A, little endian.

The decryption seems to have actually worked! I'm not sure about the flow control yet and we have _way more_ functions now (at least as Ghidra assumes), but if it hadn't compiled correctly, we wouldn't see such logical things as e. g. a reference to Java exception in pseudo c:

```c
bool FUN_00020354(long *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  char cVar1;
  long lVar2;

  cVar1 = (**(code **)(*param_1 + 0x100))();
  if ((cVar1 == '\0') &&
     (lVar2 = (**(code **)(*param_1 + 0x30))(param_1,s_java/lang/ClassCastException_00015f84),
     lVar2 != 0)) {
    (**(code **)(*param_1 + 0x70))(param_1,lVar2,param_4);
    (**(code **)(*param_1 + 0xb8))(param_1,lVar2);
  }
  return cVar1 == '\0';
}
```

Unfortunately I'm not sure how to go about deobfuscating or understanding these hundreds of functions 🫠

My best bet was to search for strings, but I didn't find anything interesting, perhaps only encrypted things.

### Detour

My initial script had also grepped this inside jadx output:

```log
[*] GREPPING FOR BASE64...
[*] FOUND BASE64: byte[] bArrDecode = Base64.decode(image.getData(), 0); in /home/litoracle/projects/apk8/malicious-apk-suite/jadx/sources/de/thefeiter/xournalviewer/MainActivityKt.java at line 159
```

Since this could be payload hidden inside an image, perhaps this is worth lookint into.

Nope, it's just creating an Android `BitMap` object.
